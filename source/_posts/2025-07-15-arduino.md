---
layout: post
title: "Inside the Box: Everything I did with an Arduino Starter Kit"
comments: true
categories: [hardware]
tags: [hardware]
description: "Diving into Elegoo Arduino Uno R3 Starter Kit, the most complete Arduino kit"
ogp_image: "/files/arduino/thumb/pelegoo_compressed.jpg"
ogp_image_twitter: "/files/arduino/thumb/pelegoo_compressed.jpg"
published: true
---

Earlier this year I saw a [Tech Ingredients episode](https://www.youtube.com/watch?v=IrocytwdeEY) where a laser gimbal automatically tracks drones and shoots them down. I was fascinated by their motion control mechanism, specially the usage of a PI Controller, a high-frequency clock [Teensy microcontroller](https://www.pjrc.com/store/teensy40.html), and their integration with custom hardware and a machine vision powered tracker.

Soon after I was researching the underlying electronics and how to experiment upon their concepts. The most obvious microcontroller to drive these would be an Arduino, but several recommendations pointed towards acquiring a kit rather than a single microcontroller, and the [Elegoo Arduino Uno R3 Starter Kit](https://www.amazon.co.uk/ELEGOO-Complete-Ultimate-controller-Compatible/dp/B01IUY62RM) seemed the best.

The kit contains over 200 components and an [extensive guided tutorial](https://www.elegoo.com/en-gb/blogs/arduino-projects/elegoo-uno-r3-project-the-most-complete-starter-kit-tutorial), which I've completed (except for the last section using an extra expansion shield). In this article, I'll go through the highlights of this journey, delightful deviations along the way, and exploration of core electronics concepts. Let's dive in!

{% imgopt /files/arduino/pelegoo ELEGOO UNO R3 Project The Most Complete Starter Kit %}

<!--more-->

<br/>

# LEDs

## Hello World: Light up a LED

I've been involved with electronics in different ways throughout my life, but surprisingly I hadn't yet done its Hello World equivalent, which is to light up a LED. This simple exercise it by itself incredibly interesting that opened a series of questions:

- Q: Why is a resistor needed? A: High current and increased temperature damage its delicate heterojunction structures, which eventually cause it to burnout
- Q: What happens if the polarity is inverted? A: Similar to a normal diode, current will not flow and the LED will not light up. As long as this reverse power is not high, the LED will not burn and can still be used with correct polarity afterwards
- Q: How to interpret its data sheet? A: There are several interesting aspects its datasheet, like the LED's wavelength curve, operating current and voltage, etc

{% imgopt /files/arduino/first_led First LED %}


## RGB LED [<a href="/files/arduino/code/RGB_LED/RGB_LED.ino">Code</a>]

RGB LEDs package a red, green and blue LED inside it that can be controlled independently, allowing for wide range color representation using three [pulse width modulation (PWM)](https://en.wikipedia.org/wiki/Pulse-width_modulation) outputs from the Arduino. 

PWM is a technique used to control the average power delivered to an electrical device by varying the width of pulses in a digital signal, which when done fast enough in a visual output such as a LED, is perceived to the human eye as being of a smooth continuous amplitude, instead of a stream of single bursts.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="1bmbdcjRWGw"></div></div>
   <p class="media-caption media-caption-two">Progressively changing the colors of a RGB LED</p>
 </div>
</center>

## 8 LEDs controlled via 74HC595 [<a href="/files/arduino/code/Eight_LED_with_74HC595_Flash_LED/Eight_LED_with_74HC595_Flash_LED.ino">Code</a>]

We can attach an 74HC595 IC to extend the number of outputs possible by an Arduino, at the cost of some latency.

When writing the desired values for each of the inputs into 74HC595, they won't be externalized until its latch is activated. Once the latch is triggered, all of the stored inputs will be externalized in one go. Very similar purpose of double buffering in video. A flicker free experience.

We are essentially controlling a piece of very limited external memory.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="ZynZlZXmAEg"></div></div>
   <p class="media-caption media-caption-two">8 LEDs controlled via 74HC595</p>
 </div>
</center>

## Smooth LED intensity fade out using capacitors

Capacitors are essentially energy stores (i.e. batteries) that with consistent charge and discharge times. By placing a condenser (or two, as in this video, so that their capacitance is summed up) in parallel with a LED, when powering the circuit both the LED immediately lights up and the condenser(s) charge in tandem. Once the main power source is removed, the condenser(s) start to smoothly discharge into the LED, creating a smooth fade out of their intensity.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="zUVHBHP2ehI"></div></div>
   <p class="media-caption media-caption-two">Smooth LED intensity variation using Capacitors</p>
 </div>
</center>


# Display

## One Unit Segment Display: Digit Countdown [<a href="/files/arduino/code/74HC595_And_Segment_Display/74HC595_And_Segment_Display.ino">Code</a>]

We can control this single unit seven segment display at the segment level, and in this example we sequentially write a set of segment sets that we perceive as digits.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="2NdN3Wmdjgc"></div></div>
   <p class="media-caption media-caption-two">Digit Countdown</p>
 </div>
</center>

## One Unit Segment Display: Custom Patterns [<a href="/files/arduino/code/74HC595_And_Segment_Display_custom_config/74HC595_And_Segment_Display_custom_config.ino">Code</a>]

We can also create any patterns, in whichever sequence and timing we so desire. Here are three examples of some custom patterns.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="AvawHVPoQ6Y"></div></div>
   <p class="media-caption media-caption-two">Rotation Pattern</p>
 </div>
</center>

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="qHU0Z2o-reE"></div></div>
   <p class="media-caption media-caption-two">Figure Eight Pattern</p>
 </div>
</center>

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="6THY1S3vVis"></div></div>
   <p class="media-caption media-caption-two">Alternating Pattern</p>
 </div>
</center>

## Four Unit Segment Display: Same Character for All [<a href="/files/arduino/code/four_digital_show_same_all/four_digital_show_same_all.ino">Code</a>]

Expanding on the above, if we write the same patterns as above on a four unit segment display, we see these replicated on all units.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="qRiBG2rDb5w"></div></div>
   <p class="media-caption media-caption-two">Same Character for All</p>
 </div>
</center>

## Four Unit Segment Display: Distinct Characters [<a href="/files/arduino/code/four_digital_show_different/four_digital_show_different.ino">Code</a>]

In order for each of the units to present their specific segment pattern, we need to write the pattern and then select which of the units should have this pattern written to, wait for a short amount of time, and then move to the next unit, where we will do the exact same thing, only this time selecting the unit(s) that should have this pattern written.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="eAKLezjvhr0"></div></div>
   <p class="media-caption media-caption-two">Distinct Characters</p>
 </div>
</center>


## LED Matrix: Scrolling [<a href="/files/arduino/code/led_matrix_and_potentiometer/led_matrix_and_potentiometer.ino">Code</a>]

This LED Matrix accepts an explicit bitmap, where each of the pixels is either enabled or disabled. To achieve a scrolling effect we set an offset based on value received via the potentiometer.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="mRT8tEqMw3k"></div></div>
   <p class="media-caption media-caption-two">Scrolling through a bitmap</p>
 </div>
</center>



## LCD Display: Showing a Long String [<a href="/files/arduino/code/lcd_very_long_string/lcd_very_long_string.ino">Code</a>]

The scrolling effect is achieved by leveraging a functionality from the [LiquidCrystal](https://docs.arduino.cc/learn/electronics/lcd-displays/) library. Here we are using a string of normal characters, but custom characters can also be used.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="SwysEippBVY"></div></div>
   <p class="media-caption media-caption-two">Scrolling through a long string</p>
 </div>
</center>


# Sound

## Buzzer

From the guide: "We should be careful not to use the UNO R3 board analogWrite() function to generate a pulse to the active buzzer, because the pulse output of analogWrite() is fixed (500Hz)". I've used `analogWrite()`, and this is the result:

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="dnI2y1cePIo"></div></div>
   <p class="media-caption media-caption-two">Varying the pitch of a buzzer</p>
 </div>
</center>

## Making the buzzer sound like an 8-bit engine [<a href="/files/arduino/code/motor_engine_sound.zip">Code</a>]

By adjusting the frequency in which the buzzer is discretely triggered, we can achieve a perceived effect similar to PWM used above for controlling LEDs intensity, only this time to allude to a certain sound pitch, which in this case is quite similar to the sonority from older computer / console games.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="dX1in8BHiv4"></div></div>
   <p class="media-caption media-caption-two">"8bit" engine sound using a buzzer</p>
 </div>
</center>

## Sensing Sound [<a href="/files/arduino/code/sound_sensor/sound_sensor.ino">Code</a>]

I've burned the on-board LED (13) while voice fiddling with this integration, since one of the dupont wires touched a wrong spot of the board while going through this.

The red LED represents audio peaks, the yellow LED represents audio troughs.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="mPdCdz7o618"></div></div>
   <p class="media-caption media-caption-two">Detecting snapping of fingers and voice</p>
 </div>
</center>


# Spatial Sensors

## Tilt ball switch [<a href="/files/arduino/code/Ball_Switch/Ball_Switch.ino">Code</a>]

This component consists of a very conductive sphere that is free to move inside the component's cylindrical shape. One face of the cylinder conducts electricity, and the opposite does not.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="ohKZl3ug6Gs"></div></div>
   <p class="media-caption media-caption-two">Tilting the component to elicit its change of state</p>
 </div>
</center>

## Ultrasonic sensor to measure distances [<a href="/files/arduino/code/distance_echo_custom_algo_and_led/distance_echo_custom_algo_and_led.ino">Code</a>]

I wondered why an external module was required to calculate distances, so I've implemented an algorithm from scratch that took into account the speed of sound and the time taken by an ultrasonic pulse to be received back by the sensor. I've validated the measurements using a real life ruler, and they were actually accurate! No external code modules required.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="w9usLWrZSSw"></div></div>
   <p class="media-caption media-caption-two">Distance measurement using custom algorithm built from scratch</p>
 </div>
</center>

## Passive infrared sensor (PIR) Motion Sensor [<a href="/files/arduino/code/HC-SR501_pir_sensor/HC-SR501_pir_sensor.ino">Code</a>]

This is a sensor commonly used to detect movement from heat emitting, like people, and then trigger a side-effect, such as a hall light. Its output is a simple binary HIGH or LOW.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="ovEsyxWsuBo"></div></div>
   <p class="media-caption media-caption-two">Detecting motion via PIR sensor</p>
 </div>
</center>

## MPU-6050: Accelerometer and Gyroscope Plotting [<a href="/files/arduino/code/gyro_plotter/gyro_plotter.ino">Code</a>]

Used the Arduino's Serial Plotter Tool to visualize the inputs from the MPU-6050 module that bundles an accelerometer, gyro and temperature sensor.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="Ys8Gr2t1i4g"></div></div>
   <p class="media-caption media-caption-two">Accelerometer and Gyroscope Plotting</p>
 </div>
</center>

## MPU-6050: Interrupt signals [<a href="/files/arduino/code/gyro_interrupts/gyro_interrupts.ino">Code</a>]

Going through the <a href="/files/arduino/code/MPU_datasheets.zip">datasheets</a> of the gyro module, I've noticed that the module could be commanded to dispatch an interrupt signal whenever a certain threshold of movement was detected. This could be useful for low power systems for example, where this interrupt would signal that relevant movement data is starting and the main controller should be fully active.

The objective of this experiment was to make the blue LED blink whenever the gyro was disturbed, but this resulted in a mostly unpredictable output, where the root cause is likely to lie on the incorrect combination of commands needed to set up the module. Further exploration would be needed here.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="0iHUuY2QxrA"></div></div>
   <p class="media-caption media-caption-two">Attempting to get an interrupt signal when movement starts</p>
 </div>
</center>

# Environmental Sensors

## Light intensity measurement via photoresistor [<a href="/files/arduino/code/lcd_light_intensity/lcd_light_intensity.ino">Code</a>]

A photoresistor is a light-sensitive resistor whose resistance decreases when light falls on its surface, if we place wire in connected from one of Arduino's analog inputs between the photoresistor and another fixed value resistor, we are able to detect the resulting voltage caused the photoresistor's variable resistance.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="uyqq006H4nQ"></div></div>
   <p class="media-caption media-caption-two">Light intensity shown on LCD display</p>
 </div>
</center>

## Temperature measurement [<a href="/files/arduino/code/lcd_thermometer/lcd_thermometer.ino">Code</a>]

With the exact same setup as above (save from the slight tweak of the script), by replacing the photoresistor with a thermistor (which yet another variable resistor, only this time changing its resistance based on temperature) we are able to measure ambient temperature, which I manipulate by using my hand's warmth and the cooling it off by blowing air into the thermistor.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="QbPoVr0-r5Y"></div></div>
   <p class="media-caption media-caption-two">Temperature shown on LCD display</p>
 </div>
</center>

## Water level sensor [<a href="/files/arduino/code/water_level/water_level.ino">Code</a>]

This consisted of some nervous plunging of the water level sensor into a tea mug, near my computer 😬

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="jQrSKp70RdM"></div></div>
   <p class="media-caption media-caption-two">Water level sensor change as it is further submerged under water</p>
 </div>
</center>


# Actuators

## BJT Transistor driven DC motor: Controlled via On/Off Button [<a href="/files/arduino/code/bjp_transistor_driven_dc_motor/bjp_transistor_driven_dc_motor.ino">Code</a>]

The Arduino is made to drive logical circuits with low output currents, so when we want to control a high power circuit, we want our Arduino microcontroller to control the "valve", but not the "pipes" themselves. This is a perfect application for a transistor (or relays, as we'll see below), where the transistor functions as a "valve" that either lets current flow through freely, or block it completely.

The kit comes included with two models of NPN bipolar junction transistor (BJT) transistors: the PN2222 and S8050. Both are often used interchangeably (as seen in this video), but the PN2222 has a higher voltage rating for collector-to-emitter voltage (60V vs 25V), which in this case is not relevant, since we are not surpassing the 5V barrier. In these, the base is the "valve", and collector and emitter function as the "pipes".

Note here I am not using a flyback diode to protect the circuit from back EMF voltage spikes caused when the DC motor is switched off, which is not the wisest idea when performing multiple tests. I was not aware of that effect at the time, and fortunately no harm was done.


<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="94dfO0uvHt0"></div></div>
   <p class="media-caption media-caption-two">DC Motor controlled via On/Off Button</p>
 </div>
</center>


## BJT Transistor driven LED and DC motor: Controlled via Potentiometer [<a href="/files/arduino/code/bjp_transistor_driven_dc_motor_with_pot/bjp_transistor_driven_dc_motor_with_pot.ino">Code</a>]

Same setup as above, only this time we are driving a LED instead of a DC motor.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="ulzed033Iw8"></div></div>
   <p class="media-caption media-caption-two">LED controlled via Potentiometer</p>
 </div>
</center>

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="30E7BqYjadU"></div></div>
   <p class="media-caption media-caption-two">DC motor controlled via Potentiometer</p>
 </div>
</center>

## L293D driven DC Motor using battery power [<a href="/files/arduino/code/DC_Motor_with_battery/DC_Motor_with_battery.ino">Code</a>]

L293D is a neat IC that packs inside everyone one needs to drive inductive loads such as relays, solenoids, DC and bipolar stepping motors, along with bidirectional drive and overcurrent and kickback protection (so no flyback diode needed).

Notice that when attempting to drive the DC motor at low power it struggles to start its rotation, but once power is increased of a slight nudge is given, it quickly starts to rotate freely.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="bYevVZHnIJ8"></div></div>
   <p class="media-caption media-caption-two">L293D driven DC Motor using battery power</p>
 </div>
</center>

## L293D + Relay driven DC Motor [<a href="/files/arduino/code/relay_with_motor/relay_with_motor.ino">Code</a>]

Relays are larger and have slower switching speeds when compared to transistors, but handle higher currents and voltages and provide good electrical isolation.

As a fun fact, in older cars, "tick-tock" heard when activating the turn signal are actually the sound of the respective relay closing and opening the circuit to light up the blinker. Those relays are very similar to the one used here, and a similar noise can be heard in the video, as the relay closes and opens the circuit that powers the DC motor

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="MWE4fc4mA60"></div></div>
   <p class="media-caption media-caption-two">L293D + Relay driven DC Motor</p>
 </div>
</center>

## Resistor and Capacitor (RC) circuit for delayed triggering

When setting up a [Resistor and Capacitor (RC) circuit](https://en.wikipedia.org/wiki/RC_circuit), we can take advantage of its predictable charging curve to delay the activation of a transistor, which in turn can activate another set of components. Depending if the transistor is a BJT (current-controlled) or a MOSFET (voltage-controlled), they would have different current or voltage thresholds at which they allow current to flow between the collector and emitter (BJT), or drain and source (MOSFET).

In this case, a bipolar junction transistor (BJT) has its base connected to RC circuit, and upon its activation a LED and/or a DC motor are activated. Notice that the DC motor either does not have enough power to start, or barely has a delay once a smaller resistor is placed on the RC circuit, which I think to be caused by having low capacitance capacitors, and not having the ideal resistor being used on RC circuit, but this would warrant further exploration and a deeper understanding of the problem.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="xDFLzbIJ0Fc"></div></div>
   <p class="media-caption media-caption-two">Delayed LED lighting via RC Circuit + BJT Transistor</p>
 </div>
</center>

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="O5sSbXKOAi0"></div></div>
   <p class="media-caption media-caption-two">Delayed LED lighting and DC Motor via RC Circuit + Single BJT Transistor</p>
 </div>
</center>

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="jiHrOab4g6Q"></div></div>
   <p class="media-caption media-caption-two">Delayed LED lighting and DC Motor via RC Circuit + Two BJT Transistors</p>
 </div>
</center>

## Servo Motor controlled via Potentiometer [<a href="/files/arduino/code/servo_and_potentitiometer_and_button_led/servo_and_potentitiometer_and_button_led.ino">Code</a>]

Servo motors are used in applications requiring precise and controlled movement, where the motor's position, speed, and torque need to be accurately controlled. In this example a button is used to switch between the state where the servo's position is synced position defined by the potentiometer, and the state where a default servo motor position is set.

Notice as well how the slight voltage noise created when manipulating the detached potentiometer input wire, and the effect it has on the servo that is attempting to sync with these received values.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="BYPq9QgATOM"></div></div>
   <p class="media-caption media-caption-two">Servo Motor controlled via Potentiometer</p>
 </div>
</center>

## Stepper Motor: Automatic Control [<a href="/files/arduino/code/stepper_motor_custom_auto/stepper_motor_custom_auto.ino">Code</a>]

The stepping motor is a clever piece of engineering that enables precision movement [without the need of external feedback](https://youtube.com/watch?v=eyqwLiowZiU).

In this setup the motor is controlled fully by an automated script, and since the 9V battery was starting to die, it was powered via power adapter.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="uHlB0qYnwRw"></div></div>
   <p class="media-caption media-caption-two">Stepper Motor: Automatic Control</p>
 </div>
</center>

## Stepper Motor: Rotary Encoder Control, using ELEGOO script [<a href="/files/arduino/code/stepper_motor_with_encoder/stepper_motor_with_encoder.ino">Code</a>]

To the above we add a rotary encoder to send precise commands of how much we want the stepper to move. This rotary encoder is the same you'll find in several appliances such as mouse wheels, car radio knobs and washing machines.

Notice that the movement is quite jerky, and no matter how much we move the rotary encoder, only the most recent movements are actually accounted for.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="Za4kyTQsCLM"></div></div>
   <p class="media-caption media-caption-two">Stepper Motor: Rotary Encoder Control, using ELEGOO script</p>
 </div>
</center>

## Stepper Motor: Rotary Encoder Control, with Extra Precision [<a href="/files/arduino/code/stepper_motor_with_encoder_custom/stepper_motor_with_encoder_custom.ino">Code</a>]

To fix the above behaviour, this script takes into account all the movements from the rotary encoder to establish a target rotation angle that every cycle the stepper motor is correcting itself towards.

Notice that in the beginning of the video the two LEDs are lighting up as the rotary encoder is manipulated, so that we can see which are the signals captured by our script. These signals consist of a predictable [gray code](https://en.wikipedia.org/wiki/Gray_code) sequence that lets us perceive with high accuracy whether it is rotating right or left.

Once the two demonstration LEDs are disconnected, we'll have signals coming through our Arduino inputs, that we interpret leveraging the above concepts, plus we also make sure to trigger device interrupts not only for one of the inputs (as in the script above), but for both inputs, so that we can capture all movements.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="77HOMCDTdmg"></div></div>
   <p class="media-caption media-caption-two">Stepper Motor: Rotary Encoder Control, with Extra Precision</p>
 </div>
</center>

## Stepper Motor: IR Remote Control [<a href="/files/arduino/code/stepper_motor_with_remote/stepper_motor_with_remote.ino">Code</a>]

Combining the IR sensor and remote above, we can also control this stepper motor using this remote control mechanism.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="OGHNJ_zIMXU"></div></div>
   <p class="media-caption media-caption-two">Stepper Motor: IR Remote Control</p>
 </div>
</center>


# Communication Interfaces

## How Arduino Keypad Works under the hood, from scratch, without extra libraries

One of the peripherals you can provide as input to Arduino is a 16 button keypad that provides a useful human interface component for microcontroller projects.

This keypad module comes included in the [Elegoo UNO R3 Starter Kit](https://www.elegoo.com/en-gb/blogs/arduino-projects/elegoo-uno-r3-project-the-most-complete-starter-kit-tutorial), which also comes with its respective tutorial and library that helps facilitates its usage.

In this video we will code from scratch an implementation that will use this keypad module, without using extra libraries, and we will go through the respective concepts and circuits, including how pull-up resistors work (which are accessible via INPUT_PULLUP)

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="1iPnFEWHnqo"></div></div>
   <p class="media-caption media-caption-two">How Arduino Keypad Works under the hood</p>
 </div>
</center>

Supporting code:

- [Using one column source code](https://gist.github.com/lopespm/2d2ce2701ae8e726a5d497c36283d008) (as seen in the video)
- [Using two columns source code](https://gist.github.com/lopespm/0716fbecc080b6ba06d4240e269124f5)

Note that the code resorts to a fair amount of duplication, but this is explicitly show how the entire mechanism works, without occluding via abstractions


## IR Signal Replication [<a href="/files/arduino/code/attempt_to_replicate_IR_38khz_signal/attempt_to_replicate_IR_38khz_signal.ino">Code</a>]

While exploring how common [infrared communication protocols](https://en.wikipedia.org/wiki/Consumer_IR) are used in every day appliances, I wondered if it was possible punch in custom light pulses via a red LED source that could be interpreted as valid signals by the IR receiver, and started by pulsing it in 25ms intervals in order comply with the 38khz signal modulation expectation on the IR receiver (1 second / 38000 Hz ~= 25ms).

Turns out this would never work with a normal red LED, since its wavelength sits around the 640nm peak, whereas we would need a 900nm to 1000nm wavelength for an IR receiver to pick that signal.

{% imgopt /files/arduino/red_led_wavelength Typical wavelength characteristics of a red LED %}

In this attempt, I am comparing the continuous pulsing by the red LED vs the pulsing generated by a standard IR remote. An interesting follow up would be to attempt the same setup, but with a IR LED emitter instead.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="8G8a_a26kd0"></div></div>
   <p class="media-caption media-caption-two">IR Signal Replication Attempt</p>
 </div>
</center> 


## RFID Card Reader [<a href="/files/arduino/code/rfid_dump_info/rfid_dump_info.ino">Code</a>]

This video shows what the MIFARE content dump from the two cards included with the kit, but the setup is able to read minimal information from other sources, like credit cards or electronic passports.

_Note that this module reference voltage works best when connected to the Arduino's VIn output, instead of Arduino's 3.3v power output._

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="Ren_lDIDvvw"></div></div>
   <p class="media-caption media-caption-two">Content dump of the information read from the two cards included with the kit</p>
 </div>
</center>


## Joystick [<a href="/files/arduino/code/joystick_simple/joystick_simple.ino">Code</a>]

This joystick module is essentially the same used in several game controllers, and its usage is fairly straighforward using an Arduino.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="YXf3wuE9nZ4"></div></div>
   <p class="media-caption media-caption-two">Joystick module demonstration</p>
 </div>
</center>


# Communication and Storage

## Transmitting Serial Information via TX output [<a href="/files/arduino/code/sending_serial_data/sending_serial_data.ino">Code</a>]

This might come as obvious to many, but only after using `Serial.print()` on different Arduino scripts as a debugging mechanism, did I realize that this command actually sends structured information not only to the host via USB (computer), but also via Arduino's TX output. 

This video/script are very simple: they write very long strings and individual bytes to the serial interface, using a very low baud rate, so that their individual bits can be roughly seen upon the right yellow LED that is attached to the TX output. The left green LED stays enabled before we start sending commands to the serial interface, and is disabled once the writing phase is completed.

Notice that even after all writes were committed, there are still bits flowing through the TX output. This goes on until Arduino's internal serial communication buffer is completely flushed.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="V1EFe0CodHA"></div></div>
   <p class="media-caption media-caption-two">Left green LED stays enabled during writing phase. Yellow LED represents single bits in the TX communication stream</p>
 </div>
</center>

## Writing individual bits and feeding them back via RX input [<a href="/files/arduino/code/8bit_self_transmission/8bit_self_transmission.ino">Code</a>]

Building up on the above, if we write individual bits by carefully timing the a normal pin output's LOW and HIGH to comply with the [UART standard](https://docs.arduino.cc/learn/communication/uart/) to form 8 bit packets, feed these through a wire to the Arduino's Rx pin, read the resulting serial communication receive buffer, and then finally write these contents into the serial port, we are able to see these logged into the serial monitor.

This was one of the most 🤯 while fiddling around with the Arduino.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="3aVKYZIQNaU"></div></div>
   <p class="media-caption media-caption-two">Writing individual bits and feeding them back via RX input</p>
 </div>
</center>

## Sending information from the host to Arduino [<a href="/files/arduino/code/serial_read/serial_read.ino">Code</a>]

Using the Serial Monitor, we can easily send packets of information to the Arduino via Serial communication. In this script, Arduino reads from the serial communication buffer an enables or disables a LED if the corresponding received information is a zero or a one.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="8qVVttbluqg"></div></div>
   <p class="media-caption media-caption-two">Sending information from the host to Arduino</p>
 </div>
</center>

## Using internal EEPROM to persist information [<a href="/files/arduino/code/serial_read_eeprom/serial_read_eeprom.ino">Code</a>]

Building on the above setup, we integrate [ATmega's integrated EEPROM](https://youtube.com/watch?v=Sus96T) to persist information. This means that even after a power outage that information is still available, as seen in the video below.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="D3iAhWgaQ2Q"></div></div>
   <p class="media-caption media-caption-two">Using internal EEPROM to persist information</p>
 </div>
</center>


## Sending information from the host to Arduino + 74CH95 to drive LEDs [<a href="/files/arduino/code/3led_74CH95_with_serial_read/3led_74CH95_with_serial_read.ino">Code</a>]

We can attach an 74HC595 IC to extend the number of outputs possible by an Arduino, and do the same as above but for extra outputs. The setup supports 7 different LEDS, but only 3 are shown in the video, and for this specific example there is no real gain from using 74CH95 IC, other than demonstrating its usage.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="eRZ1QjW8w1c"></div></div>
   <p class="media-caption media-caption-two">Serial read side effects using 3 LEDs and 74HC595</p>
 </div>
</center>


# Time

## Real Time Clock (RTC) Module Square Wave Output [<a href="/files/arduino/code/clock_squarewave_output/clock_squarewave_output.ino">Code</a>]

I was curious about the RTC module's square wave output, and found a [YouTube video](https://youtube.com/watch?v=SXnqI23XXxQ) on how to send a command to the module that forces the square wave pin (SQW) to output a 1Hz square wave, meaning that the cycle of this wave repeats every second.

In the video, this signal is first connected to a LED, which leads it to blink every second, and then the output is directed towards Arduino's pin 8, thus showing this cycle's result on the serial output.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="6t8rYvvDC8o"></div></div>
   <p class="media-caption media-caption-two">Square Wave Output visible first on LED, then on serial output logs</p>
 </div>
</center>


# Integration

## Putting it all together: the Timer [<a href="/files/arduino/code/timer.zip">Code</a>]

The time project is the opus maximus of the provided tutorials provided by Elegoo, but there were components which were not working directly, namely the interrupt library, so I've adapted the provided example to use the built in Arduino interrupt library, and changed some of the connections, leading to a beautiful culmination of all the the lessons from above.

<center>
 <div class="video-media-caption-wrapper-two"><div class="video-wrapper-two">
  <div class="youtube-player video-frame-two" data-id="SPTvg7xPScc"></div></div>
   <p class="media-caption media-caption-two">Timer Integration</p>
 </div>
</center>
